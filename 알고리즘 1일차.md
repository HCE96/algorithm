#	알고리즘 1일차

## Python

			### input() 과 sys.stdin.readline() or sys.stdin.read 의 차이

   - int(sys.stdin.readline()) (Python3) => 4.4394초

   -  int(input()) (Python3)                       => 12.4443초
   -  Scanner > Buffer (Java)
   -  printf > cout (C++)

### map() 함수

- map(int,os.read(0,100000000).split("/n")) (Python3) => 4.4033

- map => 변환

  그냥 int 쓰는것보다 빠름

## 정렬

#### 버블정렬

- n(Best)     n^2(Worst)     1(Memory)
- 이웃한 두 값을 비교하여 정렬한다. 큰 값이 오론쪽으로 이동하는 과정이 반복되면서 비교했던 모든 값들의 최댓값이 맨 오른쪽으로 옮겨지게 된다.



#### 선택정렬

- n^2(Best)    n^2(Worst)    1(Memory)

- 주어진 배열에서 최댓값(최솟값)을 찾아 맨 오른쪽(왼쪽)값과 교체한다. 최댓값을 맨 오른쪽으로 보낸다는 점에서 버블정렬과 비슷하지만, 이웃한 두 값을 정렬하는 과정이 없기 때문에 대체로 버블정렬보다 빠르다. 최댓값을 찾아야 하므로 정렬 상태에 관계없이 언제나 O(n2)O(n2)이다.



#### 삽입 정렬

- n(Best)     n^2(Worst)     1(Memory)

- 아직 정렬되지 않은 값을 이미 정렬된 배열 사이에 끼워 넣는 과정을 반복한다. 여전히 O(n2)O(n2)이지만 평균적으로 삽입정렬이 선택정렬과 버블정렬에 비해 빠르다.

  

#### 셸 정렬

- nlogn(Best)     nlog^2(n)(Worst)      1(Memory)
- 삽입 정렬이 거의 정렬된 배열에서 최적의 성능을 냄과 동시에 값 하나씩 위치를 결정하여 비효율적이라는 점에서 착안되었다. 셸 정렬은 주어진 간격만큼 듬성듬성 떨어진 서브배열을 만들어 삽입정렬을 수행한다. 간격이 3이라면 3개의 서브배열이 만들어진다. 모든 서브배열에 대해 삽입정렬을 마쳤다면, 간격을 (보통 절반으로) 줄여 반복한다. 간격이 1이 되면 거의 정렬이 된 상태이므로 빠르게 정렬할 수 있다.



#### 병합 정렬

- nlogn(Best)      nlogn(Worst)     n(Memory)

- 폰 노이만이 개발했으며, 두 부분으로 쪼개는 작업을 재귀적으로 반복한 뒤, 쪼갠 순서의 반대로 작은 값부터 병합해나가는 분할 정복 알고리즘의 일종이다.



#### 퀵 정렬

- nlogn(Best)      nlogn ~ n^2 (Worst)    logn~n(Memory)
- 피벗(pivot, 기준값) 원소를 정하여 피벗보다 작은 값은 피벗 앞 쪽에, 피벗보다 큰 값은 피벗 뒤 쪽에 오도록 한다. 피벗 양 쪽 배열에 대해 같은 작업을 반복해나간다. 분할 정복 방법의 일종이며, 재귀 호출이 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해진다. 병합정렬은 데이터를 쪼갠 뒤 합치는 과정에서 정렬하지만, 퀵정렬은 데이터를 쪼개면서 정렬한다.

